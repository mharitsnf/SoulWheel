[gd_resource type="Resource" load_steps=3 format=2]

[ext_resource path="res://Resources/Enemies/enemy_data_model.gd" type="Script" id=1]

[sub_resource type="GDScript" id=1]
script/source = "extends Node


var preprocess
var process
var postprocess

var time_elapsed = 0

var rng = RandomNumberGenerator.new()
var tween : Tween = Tween.new()

var did_player_acted = false

signal stop_running

# Attack:
# Enemy1 has one attack pattern.
# 1. One area with constant speed.

# Defend:
# Enemy1 has one defend pattern.
# 1. One area with constant speed.


func _init(current_behavior):
	add_child(tween)
	
	var _e = connect(\"stop_running\", self, \"_on_stop_running\")
	_e = tween.connect(\"tween_all_completed\", self, \"_on_tween_all_completed\")
	
	rng.randomize()
	
	match current_behavior:
		Character.Behavior.ATTACK:
			preprocess = funcref(self, \"preprocess_a\")
			process = funcref(self, \"process_a\")
			postprocess = funcref(self, \"postprocess_a\")
		
		Character.Behavior.DEFEND:
			preprocess = funcref(self, \"preprocess_d\")
			process = funcref(self, \"process_d\")
			postprocess = funcref(self, \"postprocess_d\")


# ===== ATTACK / ENEMY'S TURN =====
func preprocess_a(pattern, behavior_idx):
	rng.randomize()
	
	match behavior_idx:
		0: return preprocess_a1(pattern)
		1: return preprocess_a2(pattern)


# behavior 1
func preprocess_a1(pattern):
	var rot_angle_variation = rng.randi_range(0, 360)
	
	for area in pattern.areas:
		# process rotation angle
		area.rot_angle += rot_angle_variation
		area.rot_angle = fmod(area.rot_angle, 360)
		if area.rot_angle < 0: area.rot_angle += 360
		
		# process thickness
		area.thickness = clamp(area.thickness, 2, 360)
		area.thickness = floor(area.thickness / 2)
	
	return pattern


# behavior 2
func preprocess_a2(pattern):
	var rot_angle_variation = rng.randi_range(0, 360)
	
	for area in pattern.areas:
		# process rotation angle
		area.rot_angle += rot_angle_variation
		area.rot_angle = fmod(area.rot_angle, 360)
		if area.rot_angle < 0: area.rot_angle += 360
		
		# process thickness
		area.thickness = clamp(area.thickness, 2, 360)
		area.thickness = floor(area.thickness / 2)
	
	return pattern


func process_a(pattern, visuals, behavior_idx):
	var result
	
	match behavior_idx:
		0: result = process_a1(pattern, visuals)
		1: result = process_a2(pattern, visuals)
	
	return result


# behavior 1
func process_a1(pattern, visuals):
	var _e
	# setup the tween
	for i in range(pattern.areas.size()):
		var area = pattern.areas[i]
		var visual = visuals[i]
		var offset = pattern.offset[i]
		
		_e = tween.interpolate_property(
			area, \"rot_angle\", 
			area.rot_angle, area.rot_angle + offset,
			pattern.process_time,
			Tween.TRANS_LINEAR, Tween.EASE_IN_OUT
		)
		
		_e = tween.interpolate_property(
			visual, \"rotation_degrees\",
			visual.rotation_degrees, visual.rotation_degrees + offset,
			pattern.process_time,
			Tween.TRANS_LINEAR, Tween.EASE_IN_OUT
		)
	
	# start the tween
	_e = tween.start()
	
	# wait until the tween is stopped regardless how it stopped;
	# by player input or time out?
	yield(self, \"stop_running\")
	
	# return
	return [pattern, did_player_acted]


# behavior 2
func process_a2(pattern, visuals):
	var _e
	# setup the tween
	for i in range(pattern.areas.size()):
		var area = pattern.areas[i]
		var visual = visuals[i]
		var offset = pattern.offset[i]
		
		_e = tween.interpolate_property(
			area, \"rot_angle\", 
			area.rot_angle, area.rot_angle + offset,
			pattern.process_time,
			Tween.TRANS_LINEAR, Tween.EASE_IN_OUT
		)
		
		_e = tween.interpolate_property(
			visual, \"rotation_degrees\",
			visual.rotation_degrees, visual.rotation_degrees + offset,
			pattern.process_time,
			Tween.TRANS_LINEAR, Tween.EASE_IN_OUT
		)
	
	# start the tween
	_e = tween.start()
	
	# wait until the tween is stopped regardless how it stopped;
	# by player input or time out?
	yield(self, \"stop_running\")
	
	# return
	return [pattern, did_player_acted]


func postprocess_a(pattern, behavior_idx):
	time_elapsed = 0
	
	match behavior_idx:
		0: return postprocess_a1(pattern)
		1: return postprocess_a2(pattern)


# behavior 1
func postprocess_a1(pattern):
	for area in pattern.areas:
		area.rot_angle = fmod(area.rot_angle, 360)
		if area.rot_angle < 0: area.rot_angle += 360
	
	return pattern


# behavior 2
func postprocess_a2(pattern):
	for area in pattern.areas:
		area.rot_angle = fmod(area.rot_angle, 360)
		if area.rot_angle < 0: area.rot_angle += 360
		
	return pattern

# ==================


# ===== DEFEND / SOUL LOCK =====
func preprocess_d(pattern, behavior_idx):
	rng.randomize()
	
	match behavior_idx:
		0: return preprocess_d1(pattern)


func preprocess_d1(pattern):
	for area in pattern.areas:
		# process rotation angle
		area.rot_angle += rng.randi_range(0, 360)
		area.rot_angle = fmod(area.rot_angle, 360)
		if area.rot_angle < 0: area.rot_angle += 360
		
		# process thickness
		area.thickness = clamp(area.thickness, 2, 360)
		area.thickness = floor(area.thickness / 2)
	
	return pattern


func process_d(pattern, visuals, behavior_idx):
	var result
	
	match behavior_idx:
		0: result = process_d1(pattern, visuals)
	
	return result


func process_d1(pattern, visuals):
	var _e
	
	# setup the tween
	for i in range(pattern.areas.size()):
		var area = pattern.areas[i]
		var visual = visuals[i]
		var offset = pattern.offset[i]
		
		_e = tween.interpolate_property(
			area, \"rot_angle\", 
			area.rot_angle, area.rot_angle + offset,
			pattern.process_time,
			Tween.TRANS_LINEAR, Tween.EASE_IN_OUT
		)
		
		_e = tween.interpolate_property(
			visual, \"rotation_degrees\",
			visual.rotation_degrees, visual.rotation_degrees + offset,
			pattern.process_time,
			Tween.TRANS_LINEAR, Tween.EASE_IN_OUT
		)
	
	# start the tween
	_e = tween.start()
	
	# wait until the tween is stopped regardless how it stopped;
	# by player input or time out?
	yield(self, \"stop_running\")
	
	# return
	return [pattern, did_player_acted]


func postprocess_d(pattern, behavior_idx):
	time_elapsed = 0
	
	match behavior_idx:
		0: return postprocess_d1(pattern)


func postprocess_d1(pattern):
	for area in pattern.areas:
		area.rot_angle = fmod(area.rot_angle, 360)
		if area.rot_angle < 0: area.rot_angle += 360
	
	return pattern
# ==================


func _input(event):
	if event.is_action_pressed(\"ui_accept\") and tween.is_active():
		did_player_acted = true
		emit_signal(\"stop_running\")


func _on_tween_all_completed():
	emit_signal(\"stop_running\")


func _on_stop_running():
	if tween.is_active():
		var _e = tween.stop_all()
"

[resource]
script = ExtResource( 1 )
max_health = 30
defend_patterns = [ {
"areas": [ {
"move_speed": 50.0,
"rot_angle": 0.0,
"thickness": 60.0
}, {
"move_speed": 150.0,
"rot_angle": 0.0,
"thickness": 15.0
} ],
"offset": [ 270.0, 720.0 ],
"process_time": 5.0
} ]
attack_patterns = [ {
"areas": [ {
"damage": 5,
"is_damage_percentage": false,
"move_speed": 50.0,
"rot_angle": 0.0,
"thickness": 30.0
}, {
"damage": 5,
"is_damage_percentage": false,
"move_speed": 50.0,
"rot_angle": 120.0,
"thickness": 30.0
}, {
"damage": 5,
"is_damage_percentage": false,
"move_speed": 50.0,
"rot_angle": 240.0,
"thickness": 30.0
} ],
"offset": [ 720.0, 720.0, 720.0 ],
"process_time": 5.0
}, {
"areas": [ {
"damage": 5,
"is_damage_percentage": false,
"move_speed": 50.0,
"rot_angle": 0.0,
"thickness": 180.0
} ],
"offset": [ 720.0 ],
"process_time": 5.0
} ]
behaviors = SubResource( 1 )
